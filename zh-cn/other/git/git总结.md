# git 个人总结

> git fetch

- 完成了仅有的但是很重要的两步:
  - 从远程仓库下载本地仓库中缺失的提交记录
  - 更新远程分支指针(如 origin/master)
- git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。
- git fetch 不会做的事:
  - 并不会改变你本地仓库的状态。它不会更新你的 master 分支，也不会修改你磁盘上的文件
  - 理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。

> git cherry-pick <提交记录>
- 如果你想将一些提交复制到当前所在的位置（HEAD）下面的话， cherry-pick 是最直接的方式了
- 通常用于bug分支合并到其他分支中（还需要先提交原有分支，而后解决冲突即可）
- 实际开发中的使用：
  - 在生产环境中出现了一个bug,此时需要先放下手头上的工作，先去解决这个bug, git stash 储藏代码。而后切换到master分支，由此创建一个新的分支，去解决这个bug,解决完成以后，合并到master分支上，此时就会有一个问题，master分支上已经解决了该bug，那么其他分支上也会有该bug,我们不需要再次拷贝代码在其他所有的分支中去重新粘贴，提交一次。做法就可以使用 git cherry-pick <刚刚的bug分支的提交记录> ，可以在每个分支中执行一下该命令，看自己。在执行该代码的时候，可能会遇到冲突，此时把冲突解决完，在执行 git add . , git cherry-pick --continue 命令，就可以了。
  - 最近项目，需要在同一个代码库中弄两个独立的分支，这两个分支以后都不会合并，那么在a分支中写了一些通用的代码，因为是通用的，所以b分支中也可能需要，这个时候就不需要再b分支中去粘贴a分支中的代码，而是使用 git cherry-pick 命令去获取这些代码。

> git cherry-pick --continue 
- 用户解决代码冲突后，第一步将修改的文件重新加入暂存区（ git add . ），第二步使用下面的命令，让 Cherry pick 过程继续执行

> git cherry-pick --abort
- 如果对合并结果不满意，也可以通过这个命令，放弃合并，代码回到操作之前的状态

> git clone <仓库名称>

克隆远程仓库中的代码，克隆时只会克隆master（有些时候是main分支做主分支）分支，其余分支需要单独检出

> git clone --depth 1 <仓库名称>

1代表最近的一次提交记录，以此类推2就是最近的两次提交记录


!> 注意，有时候由于仓库多大，导致项目克隆不下来，那么可以进行浅克隆，不需要所有的提交记录，即所有的跟踪都不需要。

`仓库为什么会越来越大`
1. 我们查看项目文件大小的时候，发现并不大，可能就10几兆，但隐藏文件`.git`文件很大
2. `.git`文件为什么会大，因为该文件中保存了所有提交记录的资源