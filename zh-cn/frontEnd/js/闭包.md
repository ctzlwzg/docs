## 闭包

### 定义
在《JavaScript高级程序设计（第四版）》中是这么定义闭包的：闭包指的是那些引用了另一个函数作用域中的变量的函数，通常是在嵌套函数中实现的。

在《你不知道的JavaScript（上卷）》中是这么定义闭包的：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

在mdn官网中是这么定义[闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)。的：闭包（closure）是一个函数以及其捆绑的周围环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。


### 举例
```js
  function fn () {
    var a = 1;
    var b = 20;
    function add () {
      a++;
      var d = 111;
      console.log(add);
      console.log(a);
      console.log(d);
    }
    return add;
  }
  debugger
  var result = fn();
  result();
  result();
  console.dir(result);
```

#### fn函数的定义
当全局js在执行的前一刻，会进行全局的预编译，产生一个全局的GO对象，并且系统会给所有全局定义的函数内部创建一个[[scope]]属性，[[scope]]中保存该函数的作用域链，即保存了GO对象。

![fn函数的定义](../../picture/闭包/fn函数的定义.png)


#### fn函数的执行，与add函数的定义
fn函数执行的前一刻，会产生函数fn的AO对象，把AO对象放在作用域链的顶端

此时fn函数的执行，会产生add函数的定义，此时系统会给add函数创建一个[[scope]]属性，[[scope]]中保存该函数的作用域链，即fn函数执行的时候fn函数的作用域链

![fn函数执行](../../picture/闭包/fn函数执行.png)

#### fn函数的执行完成，返回add函数，并赋值给result变量
fn函数执行完成后，销毁对应的AO，此时要注意的时候删除的是AO的引用，即地址，不会删除引用对应的值。（是否删除对应的堆内存的值，由垃圾回收机制决定，我们在这里不考虑）

此时result变量接收add函数 那么全局中变量result的值就变成了add函数，这时候要注意的是result函数的作用域链里面存的是什么，存的是执行期fn函数的作用域链即fn的AO，全局的GO

![fn函数执行结束](../../picture/闭包/fn函数执行结束.png)

### result此时是函数了，执行

result变成函数后，执行的前一刻，会产生一个新的AO（执行多次产生新的AO），即add函数的AO。此时执行a变量自增，a变量在add函数中AO对象中没有，程序会沿着作用域链向下寻找，找到fn的AO对象，找到了`a赋值为2`。

result执行结束，会删除result函数的AO，由于AO的值没有被其他变量引用，那么其值也会被删除。



![result函数执行前一刻](../../picture/闭包/result函数执行前一刻.png)
![result函数执行结束](../../picture/闭包/result函数执行结束.png)

再次执行result函数后 的前一刻，会产生一个新的AO（执行多次产生新的AO），即add函数的AO，此时执行a变量自增，a变量在add函数中AO对象中没有，程序会沿着作用域链向下寻找，到fn的AO对象，找到了`a赋值为3`。

result执行结束，会删除result函数的AO（确切的说是AO对象赋值为null，其值删除不掉了），由于AO的值没有被其他变量引用，那么其值也会被删除（删除是浏览器的垃圾回收机制做的）。

打印result，发现其作用域中的a变量为3。

![result函数再次执行前一刻](../../picture/闭包/result函数再次执行前一刻.png)
![result函数再次执行结束](../../picture/闭包/result函数再次执行结束.png)


> 引用《你不知道的JavaScript（上卷）》中的一段话作为总结：add()依然持有对该作用域的引用，而这个引用就叫作`闭包`

我越来越感觉，fn的AO就是那个闭包？（现在不那么认为了）。《你不知道的JavaScript（上卷）》中说的是`该作用域的引用`，`引用`这个词有深意，以前我把`这个引用`理解成为fn的AO。现在我感觉是fn的AO对象，以及其作用域链中的所有变量和函数，即add函数的`外部词法作用域`（算全局变量吗？我感觉算）。这段理解是是根据《你不知道的JavaScript（上卷）》的解释。但在《JavaScript高级程序设计（第四版）》和mdn官网中还包含了一个函数，这个函数即上面的`add函数`。

### 重新认识并定义闭包
闭包是指一个函数（我们称之为内部函数或嵌套函数）以及它所能够访问的所有外部词法作用域（这些作用域形成了一个作用域链）的组合。即`闭包`=`内部函数`+`外部词法作用域`

### 问：不会被销毁的是什么？为什么不会被销毁？
有人说是闭包。从上面的一堆分析来看，是执行期间的fn函数的AO。那么AO==闭包？

全局变量`result`接收了add函数，那么`result`函数通常就不会被销毁，由于`result`和`add`指向同一个内存地址，所以不会被销毁，由于`add函数`中需要使用到`fn函数的AO`对象中的变量，那么`fn函数的AO`也不会被销毁。那么由此判断fn中的AO并不是闭包。

### 问：如果add函数中没有使用到fn函数的AO对象中的变量，那么fn函数的AO对象是否会被销毁？

查看 add函数创建一个[[scope]]属性 的时候，有没有在add函数中使用fn函数的变量，如：a,b，是会有不同的结果的。所以如果没用使用，我认为fn函数的AO对象会被销毁。如果这一点成立，那么对于fn的AO是那个闭包的理解就是不对的了。我将再上面重新去理解闭包的含义。


### 作用：变量私有化、记住变量的最后一次修改的值（可以不修改，可以只访问）

因为闭包可以记住并访问所在的作用域，所以例子中的result函数的执行，会累加变量a的值。

### 防抖函数的应用

使用这种防抖函数的一个常见场景是处理窗口的 resize 事件或者输入框的 input 事件。因为这两个事件可能会非常频繁地触发，如果不进行防抖处理，可能会导致页面性能下降或造成不必要的计算负担
```js
/**
 * 防抖函数
 *
 * @param   {function}  fn      需要防抖的函数
 * @param   {number}  duration  间隔时间
 *
 * @return  {function}          返回防抖函数
 */
export const debounce = (fn, duration) => {
  let timeout = null;
  return function () {
    /* 时间没到又触发了函数，需要清除计时器重新计时 */
    if (timeout !== null) clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn.apply(this, arguments);
    }, duration);
  };
}
```
此时debounce 返回一个匿名函数，匿名函数可以访问timeout这个变量（定时器的ID），每次执行匿名函数的时候会判断是否有定时器ID，如果有就删除原先的定时器ID，并重新创建一个定时器，等到间隔时间（duration）到了后就会执行fn函数。


