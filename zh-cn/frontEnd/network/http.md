## http简介

1. 超文本传输协议（HTTP）是一个用户传输超媒体文档的应用层协议
2. 每次请求-相应 都是独立的，相互之间不会干扰，这种模式的协议我们称之为`无状态协议`
3. 每次请求-相应传递的消息都是纯文本（字符串）

## 同源策略
同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互
源 = 协议 + 主机 + 端口，两个源相同，称之为`同源`，两个源不同，称之为`跨源或跨域`

若`页面的源`和页面运行过程中`加载的源`不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制(尤其是ajax请求限制的最明显。css,js,img等资源的限制很宽，所以这些资源我们大部分情况下都可以访问到)

!> 记住跨域问题只有在浏览器中才有。如app就不会有跨域问题

跨越解决方案：
1. 代理
2. CORS（基本上就用这种方案）
3. ~~JSONP~~

## 代理
对于前端开发而言，大部分的跨域问题，都可以通过代理解决
代理使用的场景是：生产环境不发生跨域，但开发环境发生跨域

vue2项目中具体的代码，vue-cli脚手架
在`vue.config.js`的文件中修改
```js
module.exports = {
  devServer: {
    proxy: {
      '/api': { // 请求若以/api开头，就会将其转发到www.xxxx.com
        target: 'www.xxxx.com',
        changeOrigin: true
      }
    }
  }
}
```
!> 注意：控制台中的请求地址还是以启动项目的域名进行请求的，如 http://localhost:8080，而不是www.xxxx.com

## 跨越资源共享（CORS）
`CORS`是基于 `http1.1`的一种跨域解决方案，全称Cross-Origin Resource Sharing，跨越资源共享。

总体思路：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许。

而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响，比如有的请求只是获取数据，有的请求会修改服务器的数据

针对不同的请求，CORS规定了三种不同的交互模式
1. 简单请求
2. 需要预检的请求
3. 附带身份凭证的请求

### 简单请求的判定
当同时满足下面三个条件，浏览器会认为它是一个简单请求
1. 请求方法属于下面的一种：
  - GET
  - POST
  - HEAD

2. 请求头仅包含安全字段（也可以这么理解，自己再请求头加了新的字段，就不是简单请求，基本上不会错）
  - Accept
  - Accept-Language
  - Content-Language
  - Content-Type(需要注意额外的限制)
  - Range
  - 等等
3. Content-Type的值仅限于下列三者之一：
  - text/plain
  - multipart/form-data
  - application/x-www-form-urlencoded

### 简单请求的交互规范
当浏览器判定某个ajax跨域请求是简单请求时，会发生以下的事情
1. 请求头中会自动添加`Origin`字段，即`页面的源`
2. 服务器响应头中应包含`Access-Control-Allow-Origin`字段
   - 该字段可以是：
     - \* ：表示什么人都可以访问
     - 具体的源：`https://www.baidu.com`,表示只运行百度跨域

### 预检请求
简单请求对服务器的威胁不大，所以允许使用上述的简单简单交互就可以访问到资源

但是，如果不是简单请求，那么需要下面的进行下面的流程
1. 浏览器发送预检请求，询问服务器是否允许
  预检请求没有请求体，它包含了后续真实请求要做的事情，并且它有以下特征
  - 请求方法为`OPTIONS`
  - 没有请求体
  - 请求头包含
    - `Origin`：请求的源，和简单请求的含义一致
    - `Access-Control-Request-Method`：后续的真实请求将使用的请求方法
    - `Access-Control-Request-Headers`：后续的真实请求会改动的请求头（**不区分大小写**。测试结果：都换转成小写）
2. 服务器允许
  对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：
  - `Access-Control-Allow-Origin`：和简单请求一样，表示允许的源
  - `Access-Control-Allow-Methods`：表示允许的后续真实的请求方法
  - `Access-Control-Allow-Headers`：表示允许改动的请求头
  - `Access-Control-Max-Age`：告诉浏览器，多少秒没，对于同样的请求源、方法、头、都不需要再发送预检请求了
3. 浏览器发送真实请求（和简单请求相同）
4. 服务器完成真实的相应（和简单请求相同）

![预检请求](../../picture/http/预检请求.png)

### 面试题：谈谈你对跨域的理解？

答：浏览器有一个重要的安全策略，称之为`同源策略`，当两个源不同的时候，就称之为跨域，两个源分别指的是`页面的源`和`加载的源`。比如，我们在后台登录了，back.xxx.com的后台管理系统，登录的时候请求的接口是 api.xxx.com/login的请求，由于这两个源就是不同的，就会出现跨域的情况，要特别指出的是，我们聊跨域资源费访问，具体聊的还是对ajax请求的讨论，对于css,js,img等资源，浏览器对其限制很宽，基本上都可以获取到。那么我们就会用以下两种方式进行解决跨越，一是代理，二是CORS，最常用的方案是CORS。对于代理，很简单，对于vue-cli脚手架搭建的项目，是在`vue.config.js`的文件中配置，其他项目如vite服务器又是在其他文件中配置，具体查文档即可。然而对于CORS方法，前端不需要作任何的处理，只需要后端进行处理即可。不过我们还是要了解一下CORS的具体实现的思路：如果浏览器需要进行跨域访问服务器资源，需要得到服务器的同意。服务器是如何同意的呢？那就要对请求进行区分，一般分为两种，一种简单请求，一种是预检请求。对于简单请求，浏览器会在请求头中自动添加一个`Origin`字段，告诉服务器，页面的源是什么，服务器在响应头中会添加一个字段叫`Access-Control-Allow-Origin`,允许哪个页面的源进行资源访问，有时候后端图方便会返回*，也可以具体设置允许访问的页面的源是哪些。下面介绍下预检请求，首先还是要区分哪些请求是简单请求，这样就可以倒过来判断预检请求是哪些。当满足下面的一些情况的时候，请求是简单请求，请求类型是POST，PUT，HEAD，请求头中没有新增自定义的请求头，请求头字段`Content-Type`只包含三种格式中的一种，text/plain，multipart/form，application/x-www-form-urlencoded。没有修改为类似场景的情况如：application/json的数据类型，那么我就称这个请求为简单请求。如果浏览器判断一个请求不是简单请求，那么它会自动发起一个预检请求到服务器，其特点是请求方法为：`OPTIONS`，会带第一个请求的页面的源Origin，还有`Access-Control-Request-Method`后续请求的真实方法，`Access-Control-Request-Headers`后续真实请求改动的请求头，服务器的相应返回`Access-Control-Allow-Origin` 允许访问的页面的源，`Access-Control-Allow-Methods` 允许后续的请求的方法，`Access-Control-Allow-Headers` 允许后续修改的请求头信息，`Accsss-Control-Max-Age`告诉浏览器，多少秒之前，对于相同的页面源，相同的请求方法，相同的请求头，都不需要发送预检请求了，相应成功以后，浏览器才会发起真实的请求到服务端，获取到需要的数据。这样CORS的跨域解决方法就介绍完了。